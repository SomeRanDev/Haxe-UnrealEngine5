// Generated by Haxe-UnrealEngine5 (https://github.com/RobertBorghese/Haxe-UnrealEngine5)
package ue;

@:native("UChaosPhysicalMaterial")
@:include("Chaos/ChaosPhysicalMaterial.h")
extern class ChaosPhysicalMaterial extends Object {
	public var Friction: cpp.Float32;
	public var StaticFriction: cpp.Float32;
	public var Restitution: cpp.Float32;
	public var LinearEtherDrag: cpp.Float32;
	public var AngularEtherDrag: cpp.Float32;
	public var SleepingLinearVelocityThreshold: cpp.Float32;
	public var SleepingAngularVelocityThreshold: cpp.Float32;
}

@:forward()
@:nativeGen
abstract ConstChaosPhysicalMaterial(ChaosPhysicalMaterial) from ChaosPhysicalMaterial {
	public extern var Friction(get, never): cpp.Float32;
	public inline extern function get_Friction(): cpp.Float32 return this.Friction;
	public extern var StaticFriction(get, never): cpp.Float32;
	public inline extern function get_StaticFriction(): cpp.Float32 return this.StaticFriction;
	public extern var Restitution(get, never): cpp.Float32;
	public inline extern function get_Restitution(): cpp.Float32 return this.Restitution;
	public extern var LinearEtherDrag(get, never): cpp.Float32;
	public inline extern function get_LinearEtherDrag(): cpp.Float32 return this.LinearEtherDrag;
	public extern var AngularEtherDrag(get, never): cpp.Float32;
	public inline extern function get_AngularEtherDrag(): cpp.Float32 return this.AngularEtherDrag;
	public extern var SleepingLinearVelocityThreshold(get, never): cpp.Float32;
	public inline extern function get_SleepingLinearVelocityThreshold(): cpp.Float32 return this.SleepingLinearVelocityThreshold;
	public extern var SleepingAngularVelocityThreshold(get, never): cpp.Float32;
	public inline extern function get_SleepingAngularVelocityThreshold(): cpp.Float32 return this.SleepingAngularVelocityThreshold;
}