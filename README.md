# Haxe for Unreal Engine 5
This project provides Haxe externs and helper functions for Unreal Engine 5.

*It is currently in development, but don't let that stop you. :)*

## Why When Unreal.hx Exists?
[Unreal.hx](https://github.com/proletariatgames/unreal.hx) hasn't been updated in forever, and I want to use both Haxe and Unreal Engine 5. Unreal.hx is too confusing for me to port, and I think I'll be able to fix my own problems better by understanding things from the ground up.

Unreal.hx specifically feels difficult to work with since everything is so intertwined. The auto-generated externs have special metadata which require the macro system to parse and function, there's a variety of complicated systems to make cppia and delegates work, etc. It's great when there's an active team maintaining it, but now it's just become a mess too complicated for idiots like me to figure out for themselves. This project aims to hopefully prevent such compleity issues by splitting things into bite-sized, modular pieces.

# Three Levels of Development

To keep things from getting too complicated/confusing, this project is split into three separate parts. Each piece builds upon the last to provide three different workflows for development using Haxe for Unreal Engine 5. However, each level is able to work independently, so if any future person is having trouble making something work they can drop down to a lower level of this project and still have some reliable features to work off of.

## (Level 1) Externs
The first "level" is the Unreal Engine externs. The externs generated by this project are intended to work independently without the need for any macros or Haxe metaprogramming. They simply define all of the available UClasses (and UStructs/UEnums required by the UClasses) and all the functions/variables available to the UE reflection system. `@:native` and `@:include` metadatas are provided to all of the externs to ensure the correct name and header file are used on the C++ side of things. On their own, these externs should work out of the box and be self-sufficient enough to avoid any "unknown type" errors.

Users can grab the externs from `Externs/` or generate their own in `ExternGenerator/`. Once the files are copied into their project, they don't need to do anything else to make them work. Of course, you'll need develop your own systems for ensuring the proper metadata is applied to your Haxe classes so they work well with Unreal Engine.

## (Level 2) Build/Helper Macros
Unreal Engine C++ source and header files must follow specific rules to function properly. As long as one is careful, they can craft proper Haxe/C++ output using Haxe's builtin metadata. This is where the optional macros from this project can help. Using build macros, the proper metadata can be automatically applied to UClasses and UStructs you create (`@:nativeGen` for clean output, `@:native` that follows Unreal's naming rules, `@:cppInclude` of auto-generated UClass header, etc).

This system should allow for clean, human-readable Haxe code that functions similarly to the property workflow of Unreal's C++.
```haxe
@:uclass
class MyActor extends Actor {
    @:uprop(BlueprintReadWrite)
    var Speed: Float;
    
    @:ufunc
    public function BlueprintFunc() {
        trace("This function can be called from blueprints.");
    }
}
```

## (Level 3) CPPIA Scripting
While the first two levels should provide Haxe/C++ capabilities for interacting with Unreal Engine, this third level will build upon them by adding CPPIA support. This should allow fast-paced testing by quickly compiling and reloading CPPIA bytecode. 

(No promises I'll be able to create this, I don't really understand CPPIA atm, but I will at least give it a good shot.)

# License

MIT License

Copyright (c) 2022 RoBBoR (Robert Borghese)
